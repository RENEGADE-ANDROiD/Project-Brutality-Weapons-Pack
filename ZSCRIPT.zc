version "4.14.2"

// PBWP_Core
#include "zscript/PBWP_Core/BeefCore.zs"
#include "zscript/PBWP_Core/BeefMisc.zs"
#include "zscript/PBWP_Core/BeefCore_Replacement.zs"
#include "zscript/PBWP_Core/BeefCore_Melee.zs"
#include "zscript/PBWP_Core/BeefJMod.zs"
#include "zscript/PBWP_Core/BeefMelee.zs"
#include "zscript/PBWP_Core/AllWeaponSpawner.zc"
#include "zscript/PBWP_Core/PBWP_Projectiles.zs"


// Monster Drop Handler
#include "zscript/PBWP_Core/BeefHandler.zs"
#include "zscript/PBWP_Core/BeefMonsterDropSpawnerA.zs"
#include "zscript/PBWP_Core/BeefMonsterDropSpawnerB.zs"


// PBWP_Systems
// KillStreak// 
#include "zscript/PBWP_Systems/Killstreak/KSHandler.zc"
#include "zscript/PBWP_Systems/Killstreak/KillStreak.zc"
#include "zscript/PBWP_Systems/Killstreak/PBWPHUDMessage.zs"
// Random Weapon Switch
#include "zscript/PBWP_Systems/Random Weapon Switcher/ZRWSwitchMenu.zc"
#include "zscript/PBWP_Systems/Random Weapon Switcher/ZRWSwitcher.zc"
// Doorbuster
#include "zscript/PBWP_Systems/Doorbuster/doorbuster.zs"
#include "zscript/PBWP_Systems/Doorbuster/doorbuster_handler.zs"

// PBWP_Misc
#include "zscript/PBWP_Misc/GORENEST.zs"
// ElementalismBoss
#include "zscript/PBWP_Misc/BEHOLD_BOSSES/E1_Export_1.zs"
// Player Pawn Insanity Beef: Will this be added later?
//#include "zscript/CustomPlayerClass/INPlayer.zc"
//#include "ZScript/CustomPlayerClass/PBMeleePlayer.zc"
// Spawners ZScript
#include "zscript/Insanity's Nightmare/ChainsawSpawn.zc"
#include "zscript/Weapons/Slot-3/CSSG/CSSGEvent.zs"
// Weapon Wheel Stuff
#include "zscript/Weapons/Slot-3/CSSG/CSSG_Wheel.zs"
#include "zscript/Weapons/Slot-0/DemonicExterminator/DemonicExt_Wheel.zs"
#include "zscript/Insanity's Nightmare/IN_SpecialWheeltest.zs"
#include "Zscript/PBWP_Misc/Individual_WeaponWheels/D2016Shotgun_Wheel.zs" 
#include "Zscript/PBWP_Misc/Individual_WeaponWheels/ASG_Wheel.zs"
// Casings
#include "zscript/Weapons/Slot-3/CSSG/Casings.zs"
#include "zscript/Insanity's Nightmare/HASGCasings.zc"
#include "zscript/Insanity's Nightmare/IN_BulletSystem.zc"
#include "zscript/Insanity's Nightmare/IN_SpecialProjectile.zc"
#include "zscript/Insanity's Nightmare/PlasmaRifleAssaultProjectile.zc"

// Weapons & Etc (Testing)

	// CSSG Stuff Begin
#include "zscript/Weapons/Slot-3/CSSG/CSSG.zs"
#include "zscript/Weapons/Slot-3/CSSG/CSSG_Upgrades.zs"
	// CSSG Stuff End
#include "ZScript/Weapons/Slot-4/HeavySniperRifle.zs"
#include "ZScript/Weapons/Slot-6/Excavator.zs"
#include "zscript/Weapons/Slot-8/LoRCalamityBlade.zs"
	// Demonic Exterminator Stuff Begin
#include "zscript/Weapons/Slot-0/DemonicExterminator/DemonicExt.zs"
#include "zscript/Weapons/Slot-0/DemonicExterminator/DemonicExtFunctions.zs"
#include "zscript/Weapons/Slot-0/DemonicExterminator/DemonicExtAttacks.zs"
#include "zscript/Weapons/Slot-0/DemonicExterminator/DemonicExtProj.zs"
#include "zscript/Weapons/Slot-0/DemonicExterminator/DemonicExtProj2.zs"
#include "zscript/Weapons/Slot-0/DemonicExterminator/DemonicExtProj3.zs"
#include "zscript/Weapons/Slot-0/DemonicExterminator/DemonicExtStuff.zs"
	// Demonic Exterminator Stuff End
// Dragon Sector Item Magnet
// Container Object for Storing items that can't be picked up right now.
class itemInfo : Object 
{
    Inventory item; // Item pointer of item that failed to be picked up.
    int timeAdded; // The time at which it was added to the array.

    static itemInfo Create(Inventory item, int time)
    {
        let itm = new("itemInfo");
        itm.item = item;
        itm.timeAdded = time;
        return itm;
    }
}

Class DS_ItemMagnet : Inventory
{
	double PickupRange; // Distance the Magnet can pull in from
	property PickupRange : PickupRange; // Property for easily changing Range.
	double PullSpeed; // How fast items will be pulled toward you.
	property PullSpeed : PullSpeed;
	array <Inventory> FoundItems; // Dynamic Array to store potentially pullable items into.
	Array<itemInfo> CantPickupForNow; // Items that couldn't be picked up are added here for a time.

	static const Name ExcludeReplaced[] = // Items the Vacuum will not pull.
	{
		'SoulSphere', 'MegaSphere', 'BlurSphere', 'BlueArmor', 'GreenArmor', 'Medikit', 'StimPack', 'RadSuit',
		'Infrared', 'InvulnerabilitySphere', 'Allmap', 'Backpack', 'Berserk', 'RedCard',
		'BlueCard', "YellowCard", 'RedSkull', 'BlueSkull', 'YellowSkull'
	};

	static const Name ModSpecific[] = // Exclude Mod-specific Items from being pulled.
	{
		// --- Project Brutality Specific Excludes
		'PB_SGMagazine', 'PB_AutoshotgunUpgrade', 'RifleUpgrade', 'PB_MinigunUpgrade',
		'PB_M2Upgrade', 'PB_FlamethrowerUpgrade', 'PB_Backpack', 'PB_BlueArmor',
		'PB_GreenArmor', 'PB_Stimpack', 'PB_Medikit', 'PB_Doomsphere', 'PB_Haste',
		
		// --- Dragon Sector Specific Excludes
		'DS_HealthSphere', 'DS_HealthRegen', 'DS_PoisonImmunePickup', 'Rebreather',
		'DS_DamageAbsorb', 'DS_DamageAmp', 'DS_PowerUpExtender', 'DS_ItemMagnet', 'DS_ItemMagnetUpgrade',
		'DS_MegaPower', 'DS_ArmorBuff'
	};

	// Call to start the process of pulling:
	void FindPullableItems(double dist = 256)
	{
		if (!owner)
			return;

		BlockThingsIterator itemfinder = BlockThingsIterator.Create(owner, owner.radius + dist);
		while (itemfinder.Next())
		{
			let item = Inventory(itemfinder.thing);
			// It's an item, has no owner, ShouldPull returns true, and isn't yet in the array:
			if (item && !item.owner && ShouldPull(item) && FoundItems.Find(item) == FoundItems.Size())
			{
				// Push into the array:
				FoundItems.Push(item);
			}
		}
	}

	bool ShouldPull(Inventory item)
	{
		// Exclude specific classes from being pulled.
	//	if (item is 'Weapon' || item.bBigPowerup)
	//		{
				//console.Printf("Ignoring Weapon or Big Powerup: %s", item.GetClassName());
		//		return False;
	//		}

		// Exclude specific items from the ExcludeReplacements Array.
		for (int i; i < ExcludeReplaced.Size(); i++)
		{
			if (item.GetClass() is GetReplacement(ExcludeReplaced[i]))
			{
				//let RepItem = GetReplacee(item.GetClass());
				//console.Printf("Ignoring Replaced: %s", RepItem.GetClassName());
				return False;
			}
		}

		// Check for, and if they exist, Exclude PB Items from being pulled in.
		for (int i; i < ModSpecific.Size(); i++)
		{
			Class<Inventory> moditem = ModSpecific[i];
			if (moditem && item.GetClassName() == moditem)
			{
				//console.Printf("Ignoring Mod Specific: %s", item.GetClassName());
				return False;

			}
		}

		// Make sure the item isn't in the list of items that can't be picked up right now.
		for (int i; i < CantPickupForNow.Size(); i++)
		{
			let ItemData = CantPickUpForNow[i];
			if (ItemData.item == item && level.time - ItemData.timeAdded >= 700)
			{
				CantPickupForNow.Delete(i);
				return True;
			}
			else if (ItemData.item == item && level.time - ItemData.timeAdded < 700)
				return False;
		}

		// Don't add items that are in your immediate area.
		if (item.Distance3D(owner) <= item.radius + owner.radius)
			return False;

		// If an item is found, check that it has line-of-sight to the player, if not, move on.
		if (!item.CheckSight(owner, SF_IGNOREWATERBOUNDARY))
			return False;
		return True;
	}

	// This has to be called every tick to perform pulling and pickup:
	void PullFoundItems(double maxdist = 256, double pullspeed = 15)
	{
		if (!owner)
			return;

		if (FoundItems.Size() == 0)
			return;

		for (int i = FoundItems.Size() - 1; i >= 0; i--)
		{
			if (i >= FoundItems.Size() || !FoundItems[i])
				continue;

			let item = FoundItems[i];
			// If it's too far, drop it and delete from array:
			if (item.owner || owner.Distance3D(item) > maxdist)
			{
				item.A_Stop();
				FoundItems.Delete(i);
				continue;
			}
			// If it can't see the player, move on.
			if (!item.CheckSight(owner, SF_IGNOREWATERBOUNDARY))
			{
				FoundItems.Delete(i);
				continue;
			}

			// If it's too close, force the owner to pick it up and remove from the array:
			if (owner.Distance3D(item) <= item.radius + owner.radius)
			{
				if (item.CallTryPickup(owner))
				{
					item.PlayPickupSound(owner);
					item.PrintPickupMessage(owner.CheckLocalView(), item.PickupMessage());
                    item.SetGiveAmount(owner, item.Amount, false);
					if (item.bCOUNTITEM) // If the item should be counted , increment item counts.
					{
						if (owner.player)
							owner.player.itemcount++;
						level.found_items++;
					}
				}
				else  // Stop the item and then add it it's the current game tic to the CantPickupForNow array.
				{
					item.A_Stop();
					CantPickupForNow.Push(itemInfo.Create(item, level.time));
				}
				FoundItems.Delete(i);
				continue;
			}
		
			// Otherwise move it towards the owner (specifically, its center):
			let dir = Level.Vec3Diff(item.pos, owner.pos + (0,0,owner.height * 0.5)).Unit();
			item.bNOBLOCKMONST = true;
			item.bNOCLIP = true;
			item.vel = dir * pullspeed;
		}
	}

	override void DoEffect()
	{
		super.DoEffect();
		if (isFrozen())
			return;
			
		let barmor = BasicArmor(owner.FindInventory("BasicArmor"));
		if (barmor && barmor.Amount > 0)
		{
			if (level.time % 2 == 0) // Poll for items every 2 tics.
			{
				FindPullableItems(dist: PickupRange);
			}
			PullFoundItems(PickupRange, PullSpeed); // Actually pull items.
		}

	}
    Default
    {
		//$Category "Custom Powerups"
		//$Title "Item Magnet"
		Inventory.MaxAmount 1;
		Inventory.Amount 1;
		-COUNTITEM;
		Scale 0.25;
		Radius 16;
		Height 32;
		DS_ItemMagnet.PickupRange 384;
		DS_ItemMagnet.PullSpeed 25;
	}
	states 
	{
	Spawn:
		ITMG A -1 Bright;
		stop;
	}
}

Class DS_ItemMagnetUpgrade : Inventory
{
	double UpgradedRange; // The new Range to Upgrade the Magnet to.
	property UpgradedRange : UpgradedRange; // The property that will hold this new Range.
	double UpgradedSpeed; // The new Speed of the items being pulled in.
	property UpgradedSpeed : UpgradedSpeed; // The Property to hold this Speed value.
	override bool TryPickup(in out Actor toucher)
	{
		let ret = super.TryPickup(toucher);
		if (ret)
		{
			let magnet = DS_ItemMagnet(toucher.FindInventory("DS_ItemMagnet"));
			if (!magnet)
			{
				toucher.GiveInventory("DS_ItemMagnet", 1);
				self.Destroy();
			}
			else if (magnet && magnet.PickupRange >= 0)
			{
				magnet.PickupRange = UpgradedRange;
				magnet.PullSpeed = UpgradedSpeed;
				if (ds_debugmessages && magnet) console.Printf("Pickup Range: %f - Speed: %f", magnet.PickupRange, magnet.PullSpeed);
			}
		}
		return ret;
	}
    Default
    {
		//$Category "Custom Powerups"
		//$Title "Item Magnet Extender"
		Inventory.MaxAmount 1;
		Inventory.Amount 1;
		-COUNTITEM;
		Scale 0.25;
		Radius 16;
		Height 32;
		DS_ItemMagnetUpgrade.UpgradedRange 1024;
		DS_ItemMagnetUpgrade.UpgradedSpeed 32.25;
	}
	states 
	{
	Spawn:
		ITMG B -1 Bright;
		stop;
	}
}

Class DS_MagnetHandler : EventHandler
{
	// Shortcut function for displaying item icons.
	ui void DS_DisplayIcon(TextureID icon, double xpos = 10, double ypos = 10, int vwidth = 1280, int vheight = 720, double xyscale = 0.21, double opacity = 1.0)
	{
		Screen.DrawTexture(icon, 
		true, xpos, ypos,
		DTA_ScaleX, xyscale,
		DTA_ScaleY, xyscale,
		DTA_Alpha, opacity,
		DTA_VirtualWidth, vwidth,
		DTA_VirtualHeight, vheight,
		DTA_KeepRatio,true);
	}

	// Overlay for the HUD Elements.
	override void RenderOverlay(renderevent e)
	{
		let pmo = players[consoleplayer].mo; // Player Map Object
		let plarmor = BasicArmor(pmo.FindInventory("BasicArmor")); // How much armor the player has.

		if (!pmo) return; // If the Player Map Object isn't found, just stop.

		// Left Side of the Screen.
		// Setup the Item Magnet Icon
		TextureID mag1icon = TexMan.CheckForTexture("ITMGA0"); // Level 1 Magnet Icon
		TextureID mag2icon = TexMan.CheckForTexture("ITMGB0"); // Level 2 Magnet Icon
		TextureID magofficon = TexMan.CheckForTexture("ITMGC0"); // Inactive Magnet Icon
		let magnet1 = DS_ItemMagnet(pmo.FindInventory("DS_ItemMagnet"));
		let magnet2 = DS_ItemMagnetUpgrade(pmo.FindInventory("DS_ItemMagnetUpgrade"));

		if (magnet1 || magnet2)
		{
			DS_DisplayIcon((plarmor && plarmor.Amount < 1) ? magofficon : (magnet1 && magnet2) ? mag2icon : mag1icon, xpos: 24, ypos: 309);
		}
	}

	override void PlayerSpawned (PlayerEvent e)
	{
		PlayerInfo player = players[e.PlayerNumber];
		let pmo = player.mo; // Player Map Object
		if (pmo)
			pmo.GiveInventory("DS_ItemMagnet",1);
	}
	override void PlayerRespawned (PlayerEvent e)
	{
		PlayerInfo player = players[e.PlayerNumber];
		let pmo = player.mo; // Player Map Object
		if (pmo)
			pmo.GiveInventory("DS_ItemMagnet",1);
	}
}